/*
 * This is a GAnt script for Grails that is creating a configuration file for the particular application, plotdata.
 * 
 * The main problem it solves is allowing the backend to run as an ordinary Groovy script, yet still connecting to the 
 * database using the configuration and the driver extracted from Grails. 
 *
 * The script makes an assumption that database access is configured, as usual, in conf/DataSource.groovy.
 * (A more general solution can be implemented using org.codehaus.groovy.grails.commons.ConfigurationHolder).
 *
 * @Sergey Orshanskiy
 */


import groovy.sql.Sql
import grails.util.Environment
import groovy.json.StringEscapeUtils

// Global variables containing names of the two SQL tables to create.
// The assumption is that we are NOT using tables generated by the GORM mechanism but creating our own ones. 
// It is, of course, easier to use autogenerated tables, but this creates the following issues:
// 1. Issues with Hibernate and concurrency.
// 2. Need for a way to create the tables before the backend starts running. 
//    This cannot be done from pure Groovy if we want the tables to be properly autogenerated; 
//    thus, we get more logic to be executed in the Grails environment.
// 3. A priori unknown behavior of future versions of Grails. 
def SERIES_TABLE='series'
def POINTS_TABLE='points'

includeTargets << grailsScript("_GrailsInit") << grailsScript("_GrailsArgParsing") 

target(main: "Configure database access for the backend") {

def env = Environment.current.getName()

// This script will create a config and put it in the file name ${CONFIG_FILENAME}
// The user can specify a different config file name as the first command-line parameter
String CONFIG_FILENAME = "BackendConfig_${env}.groovy"
if (argsMap['params']) {
    CONFIG_FILENAME=argsMap['params'][0]
}

println "Current environment: ${env}"
println "Parsing DataSource.groovy for database connectivity settings"
def config
try {
config = new ConfigSlurper(env).parse(new File("grails-app/conf/DataSource.groovy").toURL())
} catch (java.io.FileNotFoundException e) {
	System.err << "Cannot locate DataSource.groovy: " + e
	System.exit(1)
}

_url = config.dataSource.url
_username = config.dataSource.username
_password = config.dataSource.password
_driver = config.dataSource.driverClassName

println "Testing database connection..."
println "url: ${_url}"
println "username: ${_username}"
println "password: ${_password}"
println "driver: ${_driver}"


/*
This is a better solution, to use ConfigurationHolder, since then we don't depend on the settings being in DataSource.groovy.
But then we need to run the script with run-script for this to work. Then other things get broken...
def _url      = ConfigurationHolder.config.dataSource.url 
def _username = ConfigurationHolder.config.dataSource.username 
def _password = ConfigurationHolder.config.dataSource.password 
def _driver   = ConfigurationHolder.config.dataSource.driverClassName 
*/


    def sql
	// Let's try to catch exceptions just to explain what's wrong. At least in case of MySQL...
    try {
        sql = Sql.newInstance(_url, _username, _password, _driver)
    } catch (com.mysql.jdbc.exceptions.jdbc4.CommunicationsException e) {
		System.err << "Cannot connect to ${_url}: " + e
		System.exit(2)
    } catch (com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException e) { // Of course, this is just for MySQL
        System.err <<"Wrong MySQL database name? " + e
		System.exit(3)
    } catch (java.sql.SQLException e) {
        System.err <<"Wrong database login/password? " + e
		System.exit(4)
    }

	println "OK. Connected to the database"
    println "SUCCESS! Connected to MySQL"
    def query = "SHOW DATABASES"

    println "Issuing query " + query + "..."
    sql.eachRow(query) {
      println it
    }

    println ""
	println "OK, Database test successful"

	// Since the database test was successful, it means that we were able to use the JDBC driver. In all likelihood,
	// this driver was automatically downloaded by Grails and installed, well, somewhere. Perhaps in $HOME/.grails.
	// Let's find out where it is and autogenerate code for dynamically loading this driver.
	//
	// Warning: getProtectionDomain() may sometimes fail because of security permissions, etc.
	def codeSource = Class.forName(_driver).getProtectionDomain().getCodeSource()
	println "JDBC driver was loaded from: ${codeSource}"
	
	// File jarFile = new File(codeSource.getLocation().toURI().getPath())
	// this.class.classLoader.rootLoader.addURL( new URL(\"file://${jarFile}\" ) )"
	
	
	
	println "Writing config to ${CONFIG_FILENAME}..."
	File file = new File(CONFIG_FILENAME)
	if (file.exists()) {
		System.err << " A file or a directory ${CONFIG_FILENAME} already exists, aborted!" 
		System.exit(10)
	}


	// Generating config. 
	// Note that the config is basically a Groovy script with arbitrary Groovy code. 
	// The config must have the following three functions:
	//
	// @connectToSql:
	// This function has to connect to the database and return an instance of groovy.sql.Sql.
	//
	// @createTables:
	// This function does the original table creation. It is called when you do "groovy Backend.groovy --create-tables".
	// The user can see in plain code, what actually happens, and even edit it!
	//
	// @dataToUpdate:
	// Here is the real logic of the application.
	// You can define as many series as you want, and for each one you can specify an arbitrary closure.
	// The closure can return the current memory usage, stock price, etc. 
	// Any real-time information that you would like to graph.
	// The closure returns the currently observed value, and it will be combined with the timestamp of execution.
	//
	// Note that each series is uniquely identified by a pair (type, name). For example, ("local", "freemem").
	// 
	// TODO: One should be able to specify a list of names and one closure to compute the values for all of them, returning a map.
	// This is so much more convenient for stock quotes. There is already an example function, YahooFinanceAPI.getAverage, doing just that. 
	
	file <<"""
import groovy.sql.Sql

def connectToSql() {
	this.class.classLoader.rootLoader.addURL(new URL(\"${StringEscapeUtils.escapeJava("" + codeSource.getLocation())}\") )
	sql = Sql.newInstance(\"${_url}\", \"${_username}\", \"${_password}\", \"${_driver}\")
	return sql
}

def createTables(sql) {
    sql.execute \"\"\" CREATE TABLE `${SERIES_TABLE}` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) NOT NULL,   /* name and type have to be not null */
    `type` varchar(255) NOT NULL,   /* so that (name, type) is a truly unique pair */
    PRIMARY KEY (`id`),
    UNIQUE KEY  (`name`, `type`)
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1\"\"\"

    sql.execute \"\"\" CREATE TABLE `${POINTS_TABLE}` (
    `${SERIES_TABLE}_id` bigint(20) NOT NULL,
    `time` bigint(20) NOT NULL,
    `value` double NOT NULL,
    PRIMARY KEY (`${SERIES_TABLE}_id`, `time`),
    KEY  (`${SERIES_TABLE}_id`),
    CONSTRAINT FOREIGN KEY (`${SERIES_TABLE}_id`) REFERENCES `${SERIES_TABLE}` (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1\"\"\"
}

def dataToUpdate() {
    [
        "local": 
            ["always five": {return 5},
             "timestamp":   {new Date().getTime()},
             "freemem":     {Runtime.getRuntime().freeMemory()},
             "random":      {new Random().nextInt(10)},
			 "Math sine function":         {java.lang.Math.sin(new Date().getTime() / 10000)} ],
        "stock":
            null
    ]
}

			
def sql = connectToSql()			
sql.eachRow(\"SHOW DATABASES\") {
    println it
}"""

println "Success! Test the result by running: groovy ${CONFIG_FILENAME}"
	

}


setDefaultTarget(main)